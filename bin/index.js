#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const FileEntry_1 = require("./FileEntry");
const path_1 = __importDefault(require("path"));
const options_1 = require("./options");
const transliteration_1 = require("transliteration");
run()
    .then(() => console.log("Done"))
    .catch((error) => console.error(`Error happened while generating resources:\n${error}`));
async function run() {
    checkOptions(options_1.cmdOptions);
    console.log(`Started searching resources in ${options_1.cmdOptions.dir}`);
    const resources = [];
    let content = `${options_1.cmdOptions.ts ? 'import {ImageRequireSource} from "react-native";' : ""}` +
        `\n\n/**` +
        `\n * This file is auto-generated by react-native-image-resource-generator` +
        `\n * !!! DO NOT EDIT !!!` +
        `\n * For more information check the documentation:` +
        `\n * https://github.com/svbutko/react-native-image-resource-generator` +
        `\n*/`;
    await prepareFiles(options_1.cmdOptions.dir);
    await collectEntries(options_1.cmdOptions.dir, path_1.default.join("root", path_1.default.dirname(options_1.cmdOptions.out), options_1.cmdOptions.read || ""), true, resources);
    for (const resourceEntry of resources) {
        content += generateClassExport(resourceEntry.name, resourceEntry.entries);
    }
    fs_1.default.writeFileSync(options_1.cmdOptions.out, content);
}
async function collectEntries(dir, out, isRoot, result) {
    const files = await readDir(dir);
    const item = {
        name: isRoot ? "ImageResources" : toCamelCase(dir.split(path_1.default.sep).pop()) + "Resources",
        entries: [],
    };
    const regex = new RegExp("^((?!@).)*$");
    for (const file of files) {
        if (fs_1.default.lstatSync(path_1.default.join(dir, file)).isDirectory()) {
            await collectEntries(path_1.default.join(dir, file), out, false, result);
        }
        else if (regex.exec(file)) {
            const entry = new FileEntry_1.FileEntry(dir, out, file);
            item.entries.push(entry);
        }
    }
    result.push(item);
}
function generateClassExport(className, entries) {
    return `\n\nexport class ${className} {\n${entries.map((entry) => getEntryDeclaration(entry)).join("\n")}\n}`;
}
function getEntryDeclaration(entry) {
    if (options_1.cmdOptions.ts) {
        return `  static readonly ${entry.variableName}: ImageRequireSource = require("${entry.relativeResourcePath}");`;
    }
    else {
        return `  static ${entry.variableName} = require("${entry.relativeResourcePath}");`;
    }
}
function readDir(dir) {
    return new Promise((resolve, reject) => {
        fs_1.default.readdir(dir, (err, files) => {
            if (err) {
                reject(err);
            }
            resolve(files);
        });
    });
}
function toCamelCase(str) {
    return str.substr(0, 1).toUpperCase() + str.substr(1);
}
function checkOptions(options) {
    if (options.dir == null || options.out == null) {
        throw new Error(`Missing non-optional options.\nList of options:\n ${options_1.cmdUsage}`);
    }
}
const transliterationOptions = {
    trim: true,
};
async function prepareFiles(dir) {
    const files = await readDir(dir);
    for (const file of files) {
        if (fs_1.default.lstatSync(path_1.default.join(dir, file)).isDirectory()) {
            await prepareFiles(path_1.default.join(dir, file));
        }
        else {
            const escapedFile = (0, transliteration_1.transliterate)(file, transliterationOptions)
                .replace(/[,]/g, ".")
                .replace(/[^A-Za-z0-9_@.]/g, "_");
            if (escapedFile != file) {
                fs_1.default.renameSync(path_1.default.join(dir, file), path_1.default.join(dir, escapedFile));
            }
        }
    }
}
